#+TITLE: Developer and curator setup guide
#+AUTHOR: Tom Gillespie
# [[./setup.pdf]]
#+OPTIONS: num:nil ^:nil
#+LATEX_HEADER: \usepackage[margin=1.0in]{geometry}
#+STARTUP: showall

* Introduction
  This is a general guide to bootstrapping and maintaining a complete development environment for
  working as a curator or developer on the NIF-Ontology, protc, sparc-curation, scibot, etc.
  For a general introduction to the SPARC curation process see [[./background.org]]
  The environment bootstrapped by running this file was originally developed on Gentoo,
  and is portable to other distributions with a few tweaks.

  Please report any bugs you find in this file or during the execution of any of the
  workflows described in this file to the sparc-curation GitHub
  [[https://github.com/SciCrunch/sparc-curation/issues][issue tracker]].
* Setup
  Setup takes about 3 hours.
  [[#one-shot][OS level setup]] takes about and hour, and [[#user-start-here][user setup]] takes about two hours. \\

  *If you do not have root or sudo access or do not administer the computer you are setting this up on you should start at [[#user-start-here][user setup]]*
** One shot
   :PROPERTIES:
   :CUSTOM_ID: one-shot
   :VISIBILITY: folded
   :END:
   These bits are os specific setup instructions that need to be run as =root=.
   They only need to be run once.
*** Gentoo
    #+CAPTION: /var/lib/portage/world
    #+BEGIN_SRC text
      app-editors/emacs
      app-editors/gvim
      app-text/texlive
      dev-vcs/git
      dev-scheme/racket
      dev-lisp/sbcl
      www-client/google-chrome-stable
    #+END_SRC
*** Ubuntu
    18.10 cosmic cuttlefish (and presumably other debian derivatives)

    The following need to be run in a shell where you have root (e.g. via =sudo su -=). \\

    # Remind me, why is an ssh server not provided by default!?
    #+CAPTION: Must be done locally as root prior to remote execution. \\
    #+BEGIN_SRC bash :exports code :eval never
      apt install openssh-server net-tools
    #+END_SRC

    Add your ssh public key to [[file:${HOME}/.ssh/authorized_keys][~/.ssh/authorized_keys]]
    if you want to run this remotely.

    #+NAME: ubuntu-root-setup
    #+CAPTION: Can be run remotely as root.
    #+CAPTION: texlive-full is a big boy, minimal version is
    #+CAPTION: texlive texlive-luatex texlive-latex-extra  \\
    #+BEGIN_SRC bash :exports code :eval never
      wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | apt-key add -
      echo 'deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main' \
      >> /etc/apt/sources.list.d/google-chrome.list
      add-apt-repository ppa:plt/racket
      add-apt-repository ppa:kelleyk/emacs
      add-apt-repository ppa:pypy/ppa
      apt update
      apt install build-essential lib64readline-dev rxvt-unicode htop attr tree sqlite curl git
      apt install emacs26 vim-gtk3 texlive-full pandoc hunspell
      apt install librdf0-dev python3-dev python3-pip pypy3 jupyter racket sbcl
      apt install inkscape gimp google-chrome-stable xfce4
      update-alternatives --install /usr/bin/python python /usr/bin/python3 10
      update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 10
    #+END_SRC

    Ubuntu struggles to set user specific PATHs correctly via
    =~/.profile= This code works when the user logs in. It does not
    work correctly if you =su= to the user. Not entirely sure why.
    Doesn't work on xfce either apparently. The absolute madness.
    #+NAME: user-home-paths
    #+CAPTION: Set user home PATHs for all users to simplify later steps
    #+CAPTION: FIXME for some reason if this block is treated a source block it kills html export !?
    #+BEGIN_EXAMPLE
      { cat <<EOL
      # set PATH so it includes user's private bin if it exists
      if [ -d "$HOME/bin" ] ; then
          PATH="$HOME/bin:$PATH"
      fi

      # set PATH so it includes user's private bin if it exists
      if [ -d "$HOME/.local/bin" ] ; then
          PATH="$HOME/.local/bin:$PATH"
      fi
      EOL
      } > /etc/profile.d/user-home-paths.sh
    #+END_EXAMPLE

    Other software that you will probably need at some point but that is not packaged on ubuntu.
    - [[https://imagej.net/Fiji/Downloads][Fiji/ImageJ]]

** User
   :PROPERTIES:
   :CUSTOM_ID: user-start-here
   :END:

   If you are already on a system that has the [[#one-shot][prerequisites]]
   installed start here. If you are not you will find out fairly
   quickly when the following commands fail.

*** Git name and email
    These workflows make extensive use of git.
    Git needs to know who you are (and so do we) so that it can stash files
    that you change (for example this file, which logs to itself).
    Use the email that you will use for curation or development for this.
    You should not use your primary email account for this because it will
    get a whole bunch of development related emails.

    Run the following in a terminal replacing the examples with the fields
    that apply to you.
    #+BEGIN_SRC bash :eval never
      git config --global user.name "FIRST_NAME LAST_NAME"
      git config --global user.email "MY_NAME@example.com"
    #+END_SRC

*** Bootstrapping [[./setup.org][this =setup.org= file]]
    You can run all the code in [[./setup.org][this =setup.org= file]] automatically
    using emacs [[https://orgmode.org/][org-mode]]. The easiest way to accomplish this is to
    install [[https://github.com/jkitchin/scimax][scimax]] which is an emacs starterkit for scientists and
    engineers that has everything we will need. The following steps will do this automatically for you.

    *All the code blocks in this Bootstrapping section need to be pasted into a terminal (shell) where you are logged in as your user.*
    *Run every code block in the order that they appear on this page. Do not skip any blocks.*
    *Read all the text between blocks. It will tell you what to do next.*
    
    When pasting blocks into the terminal (middles mouse, or =C-V= =control-shift-v= in the ubuntu terminal)
    if you do not copy the last newline of the blocks then you will have to hit enter to run the last command.
    #+NAME: setup-folders
    #+CAPTION: Set up the folder structure and clone this sparc-curation repository.
    #+BEGIN_SRC bash :exports code :eval never
      # TODO emacs auto setup to be able to run this file
      mkdir -p ~/.local/bin
      mkdir ~/bin
      mkdir ~/opt
      mkdir ~/git
      mkdir ~/files
      source .profile
      git clone https://github.com/SciCrunch/sparc-curation.git ~/git/sparc-curation
      ln -s ~/git/sparc-curation/docs/setup.org ~/setup.org

    #+END_SRC

    When running the next block =scimax= will launch emacs an install a number of packages (DON'T PANIC).
    It is normal to see errors during this step. When it finishes quit emacs by typing =C-x C-c=
    (control x control c, or hold control and type x and then c), or by using the file menu or the =x= button.
    #+NAME: get-fancy-emacs
    #+CAPTION: Install scimax to get the functionality to run this =setup.org= file.
    #+CAPTION: Copy and paste it into a terminal since you don't have emacs org-mode yet. \\
    #+BEGIN_SRC bash :exports code :eval never :noweb yes
      tlmgr init-usertree  # init texlive for your user
      # This is dangerous. I (Tom) have reviewed the install script at this commit.
      # Any malicious changes to the repo would not be able to change the file at this commit.
      # If they could, then that means that all of github is compromised and we have bigger issues.
      cd ~/opt
      bash -c "$(curl -fsSL https://raw.githubusercontent.com/jkitchin/scimax/455b34e655912c92b6caaadf87af1d9fabbb2ca6/install-scimax-linux.sh)"
      cd
      ln -sT ~/opt/scimax.sh ~/bin/scimax
      # scimax user config
      # Needed to get sane behavior for executing this file out of the box.
      { cat <<EOL
      ;; org goto heading
      (defun org-goto-section (heading)
        "\`heading' should be a string matching the desired heading"
        (goto-char (org-find-exact-headline-in-buffer heading)))

      ;; recenter a line set using --eval to be at the top of the buffer
      (add-hook 'emacs-startup-hook (lambda () (recenter-top-bottom 0)))

      ;; line numbers so it is harder to get lost in a big file
      (when (>= emacs-major-version 26)
        (setq display-line-numbers-grow-only 1)
        (global-display-line-numbers-mode 1))

      ;; open setup.org symlink without prompt
      (setq vc-follow-symlinks 1)

      ;; sane python indenting
      (setq-default indent-tabs-mode nil)
      (setq tab-width 4)
      (setq org-src-preserve-indentation nil)
      (setq org-src-tab-acts-natively nil)

      ;; don't hang on tlmgr since it is broken on ubuntu
      (setq scimax-installed-latex-packages t)

      ;; save command history
      (setq history-length t)
      (savehist-mode 1)
      (setq savehist-additional-variables '(kill-ring search-ring regexp-search-ring))

      ;; racket
      (use-package racket-mode
        :mode "\\.ptc\\'" "\\.rkt\\'" "\\.sxml\\'"
        :bind (:map racket-mode-map
              ("<f5>" . recompile-quietly))
        :init
        (defun my/buffer-local-tab-complete ()
          "Make \`tab-always-indent' a buffer-local variable and set it to 'complete."
          (make-local-variable 'tab-always-indent)
          (setq tab-always-indent 'complete))
        (defun rcc ()
          (set (make-local-variable 'compile-command)
               (format "raco make %s" (file-name-nondirectory buffer-file-name))))
        (add-hook 'racket-mode-hook 'rcc)
        (add-hook 'racket-mode-hook 'hs-minor-mode)
        (add-hook 'racket-mode-hook 'goto-address-mode)
        (add-hook 'racket-mode-hook 'my/buffer-local-tab-complete)
        (add-hook 'racket-repl-mode-hook 'my/buffer-local-tab-complete))

      ;; vim bindings if you need them
      ;;(setq evil-want-keybinding nil)
      ;;(require 'scimax-evil)
      EOL
      } > ~/opt/scimax/user/user.el
      scimax

    #+END_SRC

    After running the next command you should have a version of this file open locally.
    In that file go to the next header [[#per-user-setup][Per user setup]] and continue this process.

    #+NAME: launch-setup-org-1
    #+CAPTION: Run the following to open this file in an executable form.
    #+BEGIN_SRC bash :exports code :eval never
      scimax  ~/setup.org --eval '(org-goto-section "Per user setup")'
    #+END_SRC

*** Per user setup
    :PROPERTIES:
    :CUSTOM_ID: per-user-setup
    :END:
    You should now have this file open in =scimax=
    and can run the code blocks directly by clicking on a block
    and typing =C-c C-c= (control c control c). In the default
    =scimax= setup code blocks will appear as yellow or green.
    Note that not all yellow blocks are source code, some may be
    examples, you can tell because examples won't execute and the
    start with =#+BEGIN_EXAMPLE= instead of =#+BEGIN_SRC=.

    All the following should be run as your user in =scimax=.
    If you run these blocks from the command line be sure to run
    nameref:remote-exports first.

    When you run this block emacs will think for about 3 minutes
    as it retrieves everything. You can know that it is thinking
    because your mouse will be in thinking mode if you hover over
    emacs, and because in the minibuffer window at the bottom of
    the window there will be a message saying something to the
    effect of =Wrote /tmp/babel-nonsense/ob-input-nonsense=.
    If an error window appears when running this block just run
    it again.

    # FIXME why no output on first run? too many errors?
    # ANSWER i think it is because raco pkg install runs in alphabetical order
    #+CAPTION: You can run them all at once from this block.
    #+HEADER: :var REPOS=repos PYROOTS=py-roots RKTROOTS=rkt-roots
    #+BEGIN_SRC bash :results output :noweb yes :exports none :eval no-export
      <<clone-repos>>
      <<python-setup>>
      <<racket-ontology>>
      <<racket-setup>>
    #+END_SRC

    *If you run the block above you do not need to run the rest of this section*
    *and you can move on to the [[#configuration-files][Configuration files]] section.*

    #+NAME: clone-repos
    #+CAPTION: Clone all required git repositories.
    #+HEADER: :var REPOS=repos
    #+BEGIN_SRC bash :results output :eval no-export
      pushd ~/git
      for repo_url in ${REPOS}; do git clone ${repo_url}.git; done
      popd
    #+END_SRC

    #+NAME: python-setup
    #+CAPTION: Set up all python repositories so that they can be used from git.
    #+CAPTION: This also installs missing python dependencies to =~/.local/lib*/python*/site-packages=.
    #+HEADER: :var PYROOTS=py-roots
    #+BEGIN_SRC bash :results output :eval no-export
      pushd ~/git
      for repo in ${PYROOTS}; do pushd ${repo}; pip install --user --editable . || break; popd; done
      popd
    #+END_SRC

    #+NAME: racket-ontology
    #+CAPTION: Convert ontology and build as module for racket.
    #+CAPTION: This will take a bit of time to run. \\
    #+BEGIN_SRC bash :results output :eval no-export
      ln -s ~/git/rkdf/bin/ttl-to-rkt ~/bin/ttl-to-rkt
      ln -s ~/git/rkdf/bin/rkdf-convert-all ~/bin/rkdf-convert-all
      pushd ~/git/NIF-Ontology
      git checkout dev
      rkdf-convert-all
      git checkout master
      popd
    #+END_SRC

    #+NAME: racket-setup
    #+CAPTION: Install racket packages and dependencies. \\
    #+HEADER: :var RKTROOTS=rkt-roots
    #+BEGIN_SRC bash :results output :eval no-export
      pushd ~/git
      raco pkg install --skip-installed --auto --batch ${RKTROOTS}
      popd
    #+END_SRC

*** Configuration files
    :PROPERTIES:
    :CUSTOM_ID: configuration-files
    :END:

    This section creates and populates [[file:${HOME}/devconfig.yaml][~/devconfig.yaml]]
    and [[file:${HOME}/secrets.yaml][~/secrets.yaml]]. They are used to configure the
    various programs that are used by the SPARC curation workflow, and
    store the API keys and semi private information such as hypothes.is
    group names, and google doc ids.

    Each block in this section should have =#+RESULTS:= if it succeeds.

    # TODO improve the error messages (there are loads of them)
    #+NAME: config-setup
    #+CAPTION: Make =devconfig.yaml= and =secrets.yaml= available in the home directory.
    #+CAPTION: *If you don't run this block you will get some really fun errors.*
    #+BEGIN_SRC bash :eval no-export
      cd ~/
      ontutils devconfig --write &&
      chmod 0700 ~/.config/pyontutils
      ln -s ~/.config/pyontutils/devconfig.yaml
      touch ~/.config/pyontutils/secrets.yaml
      chmod 0600 ~/.config/pyontutils/secrets.yaml
      ln -s ~/.config/pyontutils/secrets.yaml
    #+END_SRC

    #+NAME: set-devconfig-paths
    #+CAPTION: Set default paths in devconfig.yaml \\
    #+BEGIN_SRC python :results value :cache yes :eval no-export
      from pathlib import Path
      from pyontutils.config import devconfig
      devconfig.scigraph_api = 'http://scigraph.olympiangods.org/scigraph'
      devconfig.secrets_file = Path('~/.config/pyontutils/secrets.yaml').expanduser()
      devconfig.git_local_base = Path('~/git').expanduser()
      return devconfig
    #+END_SRC

    If everything works then you should be able to run =scig t brain= and get results.

    #+NAME: make-secrets-template
    #+CAPTION: Add template for secrets.yaml \\
    #+BEGIN_SRC python :results value :cache yes :eval no-export
      from pathlib import Path
      import yaml
      spath = Path('~/.config/pyontutils/secrets.yaml').expanduser()
      with open(spath, 'rt') as f:
          sec = yaml.load(f)
      if not sec:
          secrets_template = {
              'hypothesis': {'api':{'replace-me-with-your-user-name': 'fake-api-key'},
                             'group':{'sparc-curation': 'FakeId12'}},
              'blackfynn': {'sparc':{'key': 'fake-api-key',
                                     'secret': 'fake-api-secret'}},
              'protocols-io': {'creds-file': '/path/to/creds-file.json'},
              'google': {'api': {'creds-file': '/path/to/creds-file.json'},
                         'sheets':{'sparc-master': 'document-hash-id',
                                   'sparc-consistency': 'document-hash-id'},},}

          with open(spath, 'wt') as f:
              yaml.dump(secrets_template, f, default_flow_style=False)

          with open(spath, 'rt') as f:
              return f.read()  # return the template so that we can verify

      else:
          return f'{spath} already exists, not writing template!'

    #+END_SRC

    You can move your [[file:${HOME}/.config/pyontutils/secrets.yaml][~/.config/pyontutils/secrets.yaml]]
    to live where ever you want, but you will need to update the =secrets_file= entry in
    [[file:${HOME}/.config/pyontutils/devconfig.yaml][~/.config/pyontutils/devconfig.yaml]].

    At this point installation is complete. Congratulations!

    *You should log out and log back in to your window manager* so that any new terminal
    you open will have access to all the programs you just installed.
    Logout on the default ubuntu window manager is located in the upper right.

    *When you you log back in* run the following command to start at the next step.
    #+NAME: launch-setup-org-2
    #+CAPTION: Run the following to open this file in an executable form.
    #+BEGIN_SRC bash :eval never
      scimax  ~/setup.org --eval '(org-goto-section "Per user setup")'
    #+END_SRC

    When you exit emacs it may ask you if you want to save,
    say yes so that the logs of the install are saved.
    # TODO FIXME
    NOTE this will cause problems down the line when you
    try to pull updates for sparc-curation because git will complain.

    The [[#accounts-and-api-access][next section]] will walk you through the steps needed
    to get access to all the various systems holding different pieces of data that we need.

*** Accounts and API access
    :PROPERTIES:
    :CUSTOM_ID: accounts-and-api-access
    :END:
    Create accounts, obtain various API keys.
    After you finish this section you can jump to [[#get-data][getting data]]!.

    The notation =(-> key1 key2 key3)= indicates a path in
    your [[file:${HOME}/secrets.yaml][secrets.yaml]] file.
    In a yaml file this looks like the block below.
    Replace the =fake-value= with the real value you obtain in the following sections.
    #+CAPTION: yaml view of =(-> key1 key2 key3)=
    #+BEGIN_SRC yaml :eval never
      key1:
        key2:
          key3: fake-value
    #+END_SRC
    You can open the [[file:${HOME}/secrets.yaml][secrets.yaml]]
    file in another buffer by clicking on the link to it here. When you edit the file and
    to add api keys you should save it after each one using the file menu or =C-x C-x=.
**** Ontology
***** SciGraph
      For some use cases you will need access to the SciCrunch production SciGraph endpoint.
      [[https://scicrunch.org/register][Register for an account]] and
      [[https://scicrunch.org/account/developer][get an api key]].
      Edit [[file:${HOME}/.config/pyontutils/devconfig.yaml][devconfig.yaml]]
      and update the =scigraph_api_user: name-of-user-or-name-for-the-key= entry.
      Edit [[file:${HOME}/.config/pyontutils/secrets.yaml][secrets.yaml]]
      and add the api key to =(-> scicrunch api name-of-user-or-name-for-the-key)=.
**** Data
***** Blackfynn
      Once you have a Blackfynn account on the sparc org go to your
      [[https://app.blackfynn.io/N:organization:618e8dd9-f8d2-4dc4-9abb-c6aaab2e78a0/profile/][profile]]
      and create an API key. Put they key in =(-> blackfynn sparc key)= and the secret in =(-> blackfynn sparc secret)=.
      +While you are there you should also connect your ORCiD.+ Broken at the moment.
**** Human workflows
***** Google
      =(-> google api creds-file)=
      https://developers.google.com/identity/protocols/OAuth2
      https://developers.google.com/api-client-library/python/guide/aaa_oauth

      You will need to get API access for a OAuth client.
      https://console.developers.google.com/apis/credentials
      create credentials -> OAuth client ID
      Fill in the consent screen, you only need the Application name field.
      Download JSON
      Get the document ids for =(-> google sheets sparc-master)= and =(-> google sheets sparc-consistency)=.
      Document id matches this pattern https://docs.google.com/spreadsheets/d/{document_id}/edit.

**** Protocol annotation set up
***** Hypothes.is
      #+CAPTION: as your user Install the hypothesis client in chrome.
      #+BEGIN_SRC bash :results none
        google-chrome-stable https://chrome.google.com/webstore/detail/hypothesis-web-pdf-annota/bjfhmglciegochdpefhhlphglcehbmek
      #+END_SRC
      To get Hypothes.is API keys [[https://web.hypothes.is/start/][create an account]],
      login, and go to your [[https://hypothes.is/account/developer][developer page]].
***** protocols.io
      To get protocols.io API keys [[https://www.protocols.io/create][create an account]],
      login, and go to your [[https://www.protocols.io/developers][developer page]].
      You will need to set the redirect uri on that page to match the redirect uri
      in the json below.

      Use the information from that page to fill in a json file with the structure below.
      Add the full path to that json file to =(-> protocols-io api creds-file)= in secrets.yaml
      like you did for the google json file.
      #+CAPTION: protocols.io creds-file.json template
      #+BEGIN_SRC js
        {
            "installed": {
                "client_id": "pr_live_id_fake-client-id<<<",
                "client_secret": "pr_live_sc_fake-client-secret<<<",
                "auth_uri": "https://www.protocols.io/api/v3/oauth/authorize",
                "token_uri": "https://www.protocols.io/api/v3/oauth/token",
                "redirect_uris": [
                    "https://sparc.olympiangods.org/curation/"
                ]
            }
        }
      #+END_SRC

      You will be prompted for your protocols.io email and password the first
      time you run.
* Workflows
** General
*** Staying up to date

    #+CAPTION: new features that you want to use?
    #+BEGIN_SRC bash :results output :var REPOS=repos
      pushd ~/git
      for d in $(ls); do if [ -d $d/.git ]; then pushd $d; git pull || break; popd; fi; done
      popd
    #+END_SRC

** SPARC
*** Get data
    :PROPERTIES:
    :CUSTOM_ID: get-data
    :END:
    If you have never retrieved the data before run.
    #+CAPTION: first time per local network
    #+BEGIN_SRC bash :results none
      pushd ~/files/blackfynn_local/
      spc clone  # initialize a new repo and pull existing structure
      scp refresh -f
      spc fetch  # actually download files
      spc find -n '*.xlsx' -n '*.csv' -n '*.tsv' -n '*.msexcel'  # see what to fetch
      spc find -n '*.xlsx' -n '*.csv' -n '*.tsv' -n '*.msexcel'-f  # fetch
      spc find -n '*.xlsx' -n '*.csv' -n '*.tsv' -n '*.msexcel'-f -r 10  # slow down you are seeing errors!
    #+END_SRC

    #+CAPTION:
    #+BEGIN_SRC bash :results none

    #+END_SRC

    Pull local copy of data to a new computer. Note the double escape needed for the space.
    #+BEGIN_SRC bash :results none :eval never
      rsync -X -u -v -r -e ssh ${REMOTE_HOST}:/home/${DATA_USER}/files/blackfynn_local/SPARC\\\ Consortium ~/files/blackfynn_local/
    #+END_SRC
    =-X= copy extended attributes
    =-u= update files
    =-v= verbose
    =-r= recursive
    =-e= remote shell to use
*** Fetch missing files
    fetching a whole dataset or a subset of a dataset
    =spc ** -f=
*** Git gud?
    *NOTE: Still experimenting with git and git annex to see if they will work for this.*
    Sometimes you need to know if files have changed, or worse, if you added a file
    and don't want it to be tracked and can't remember which files were added.
    How do we deal with this!?
    GIT TO THE RESCUE!
    Also, having this on an ssd makes it funfast.
    After finishing a =spc pull= and =spc -n "*" -l 2 -f=
    #+BEGIN_SRC bash
      cd ~/files/blackfynn_local/SPARC\ Consortium
      git init
      git add *
      git commit -m "snapshot"
    #+END_SRC
*** Reporting
    =spc stats *=
* Variables :noexport:
  :PROPERTIES:
  :VISIBILITY: folded
  :END:
  GitHub repositories
  #+NAME: tgbugs-repos
  | hyputils ontquery parsercomb pyontutils protc rrid-metadata rkdf orgstrap |
  #+NAME: sci-repos
  | NIF-Ontology scibot sparc-curation |
  #+NAME: other-repos
  | Ophirr33/pda zussitarze/qrcode |
  
  Repository local roots. The ordering of the entries matters.
  #+NAME: py-roots
  | pyontutils/htmlfn pyontutils/ttlser hyputils ontquery parsercomb pyontutils pyontutils/nifstd pyontutils/neurondm protc/protcur sparc-curation scibot |
  #+NAME: rkt-roots
  | qrcode/ pda/ protc/protc-lib protc/protc-tools-lib protc/protc protc/protc-tools rkdf/rkdf-lib rkdf/rkdf rrid-metadata/rrid NIF-Ontology/ |
  
** Make repos
   #+NAME: repos-code
   #+HEADER: :var trl=tgbugs-repos srl=sci-repos orl=other-repos
   #+BEGIN_SRC python :results value :eval no-export
     from itertools import chain
     urs = chain((('tgbugs', r) for tr in trl for rs in tr for r in rs.split(' ')),
                 (('SciCrunch', r) for sr in srl for rs in sr for r in rs.split(' ')),
                 (ur.split('/') for o_r in orl for urs in o_r for ur in urs.split(' ')))
     #print(trl, srl, orl)
     #print(list(urs))  # will express the generator so there will be no result

     out = []
     for user, repo in urs:
         out.append(f'https://github.com/{user}/{repo}')
     return [' '.join(out)]
   #+END_SRC

   #+NAME: repos
   #+RESULTS: repos-code
   | https://github.com/tgbugs/hyputils https://github.com/tgbugs/ontquery https://github.com/tgbugs/parsercomb https://github.com/tgbugs/pyontutils https://github.com/tgbugs/protc https://github.com/tgbugs/rrid-metadata https://github.com/tgbugs/rkdf https://github.com/tgbugs/orgstrap https://github.com/SciCrunch/NIF-Ontology https://github.com/SciCrunch/scibot https://github.com/SciCrunch/sparc-curation https://github.com/Ophirr33/pda https://github.com/zussitarze/qrcode |

** Variables testing
   #+CAPTION: testing
   #+HEADER: :var REPOS=repos PYROOTS=py-roots RKTROOTS=rkt-roots
   #+BEGIN_SRC bash
     for repo in ${REPOS}; do echo ${repo}; done
     echo '-------------'
     for repo in ${PYROOTS}; do echo ${repo}; done
     echo '-------------'
     for repo in ${RKTROOTS}; do echo ${repo}; done
   #+END_SRC
** Remote exports code
   #+NAME: remote-exports-code
   #+CAPTION: export commands to set if running remotely via copy and paste
   #+HEADER: :var REPOS=repos PYROOTS=py-roots RKTROOTS=rkt-roots
   #+BEGIN_SRC bash :results output code example :exports results :eval no-export
     echo export REPOS='<<EOL'
     printf "$(echo ${REPOS} | tr ' ' '\n')"
     echo
     echo EOL
     echo export PYROOTS='<<EOL'
     printf "$(echo ${PYROOTS} | tr ' ' '\n')"
     echo
     echo EOL
     echo export RKTROOTS='<<EOL'
     printf "$(echo ${RKTROOTS} | tr ' ' '\n')"
     echo
     echo EOL
   #+END_SRC
* Appendix
** Code
*** Remote exports
    Paste the results of this block into your shell if you are running
    the code from this file by pasting it into a terminal.
    #+CALL: remote-exports-code()

    #+NAME: remote-exports
    #+RESULTS:
    #+begin_src bash
    export REPOS=<<EOL
    https://github.com/tgbugs/hyputils
    https://github.com/tgbugs/ontquery
    https://github.com/tgbugs/parsercomb
    https://github.com/tgbugs/pyontutils
    https://github.com/tgbugs/protc
    https://github.com/tgbugs/rrid-metadata
    https://github.com/tgbugs/rkdf
    https://github.com/tgbugs/orgstrap
    https://github.com/SciCrunch/NIF-Ontology
    https://github.com/SciCrunch/scibot
    https://github.com/SciCrunch/sparc-curation
    https://github.com/Ophirr33/pda
    https://github.com/zussitarze/qrcode
    EOL
    export PYROOTS=<<EOL
    pyontutils/htmlfn
    pyontutils/ttlser
    hyputils
    ontquery
    parsercomb
    pyontutils
    pyontutils/nifstd
    pyontutils/neurondm
    protc/protcur
    sparc-curation
    scibot
    EOL
    export RKTROOTS=<<EOL
    qrcode/
    pda/
    protc/protc-lib
    protc/protc-tools-lib
    protc/protc
    protc/protc-tools
    rkdf/rkdf-lib
    rkdf/rkdf
    rrid-metadata/rrid
    NIF-Ontology/
    EOL
    #+end_src
